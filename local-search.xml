<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>构造函数和析构函数</title>
    <link href="/2021/10/06/constructor%20and%20destructor/"/>
    <url>/2021/10/06/constructor%20and%20destructor/</url>
    
    <content type="html"><![CDATA[<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>cpp的构造函数有很多写法，比如无参和有参的写法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>嫌麻烦的话，还可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>) : <span class="hljs-built_in">a</span>(x) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样的话，如果初始化A对象无参数传入</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">A a1;<br></code></pre></div></td></tr></table></figure><p>那么a1.a的值默认为1；</p><p>如果是有参数传入</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">999</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>那么此时a1.a的值为999。</p><h2 id="如何写子类的构造函数"><a href="#如何写子类的构造函数" class="headerlink" title="如何写子类的构造函数"></a>如何写子类的构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>) : <span class="hljs-built_in">A</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类不会继承基类的</p><ul><li>构造、析构、拷贝构造函数</li><li>重载运算符</li><li>友元函数</li></ul><h1 id="destructor"><a href="#destructor" class="headerlink" title="destructor"></a>destructor</h1><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> _a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a) &#123;&#125;<br>    ~<span class="hljs-built_in">Base</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-comment">// 最好前面加上virtual</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> _b = <span class="hljs-number">0</span>) : <span class="hljs-built_in">b</span>(_b) &#123;&#125;<br>    ~<span class="hljs-built_in">Derived</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>需要注意的是，如果用指向基类的指针操作派生类 Derived ，当其生命周期结束后，如果基类析构 不是 virtual function ，只有基类的析构函数被调用，可能会造成派生类的资源没有被释放</strong></p><blockquote><p><strong>为什么基类的析构函数是虚函数？</strong></p></blockquote><blockquote><p> <strong>在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生</strong></p></blockquote></li><li><p><strong>所以务必将 destructor 定义为 virtual function ，尤其是当成员变量有指针时</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<span class="hljs-keyword">do</span> something&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当父类的 destructor 为 virtual function 时，派生类的 destructor 默认为 vritual function ，不过最好还是在派生类的 destructor 前加上 virtual</p></li><li><p><strong>有没有必要</strong>将 destructor 声明为纯虚函数？（当有纯虚函数时，该类为抽象基类，不能实例化对象）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~Base = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>答案是<strong>能够，但要看情况</strong>。</p><p>那么这样实现的目的是什么呢？当然是<strong>避免实例化</strong>，比如Animal是不应该被实例化的，只有Dog或者Cat被实例化才有具体意义，为了避免Animal实例化，但又因为Animal没有其他的纯虚函数，所以可以将Animal的析构声明为pure virtual function</p><p>但由于<strong>派生类不可能来实现基类的析构函数</strong>，所以<strong>基类析构函数尽管能够标为纯虚，可是仍必须实现析构函数，否则派生类无法继承。也无法编译通过</strong>。</p><p>因为子类调用自己的虚析构函数前，要调用父类的析构函数，而当父类的析构为纯虚函数，如果没有在类外定义函数体，编译会失败，提示<em>没有父类的析构函数</em></p><p>可以为纯虚函数定义一个空的函数体，链接器就能找到基类的虚构函数了</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> _a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br>Base::~<span class="hljs-built_in">Base</span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编中的指针实现</title>
    <link href="/2021/08/21/reverse-pointer/"/>
    <url>/2021/08/21/reverse-pointer/</url>
    
    <content type="html"><![CDATA[<p>1.汇编中指针及多级指针的实现</p><p>2.一些简单逆向题目的复现</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span>、列出每一行的反汇编代码：<br><br><span class="hljs-keyword">char</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">short</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">char</span>* pa = &amp;a;<br><span class="hljs-keyword">short</span>* pb = &amp;b;<br><span class="hljs-keyword">int</span>* pc = &amp;c;<br><br><span class="hljs-keyword">char</span>** ppa = &amp;pa;<br><span class="hljs-keyword">short</span>** ppb = &amp;pb;<br><span class="hljs-keyword">int</span>** ppc = &amp;pc;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;1<br><br>mov byte ptr [ebp-4], A<br>mov word ptr[ebp-8], 14<br>mov dword[ebp-c] 1E<br><br>lea eax, dword ptr [ebp-4]<br>mov dword ptr [ebp-10], eax<br>lea eax dword ptr [ebp-8]<br>mov dword ptr [ebp-14], eax<br>lea eax, dowrd ptr [ebp-c]<br>mov dword ptr [ebp-18] eax<br><br>lea eax, dword ptr [ebp-10]<br>mov dowrd ptr [ebp-1C], eax<br>lea eax, dword ptr [ebp-14]<br>mov dword ptr [ebp-20], eax<br>lea eax, dword ptr [ebp-18]<br>mov dword ptr [ebp-24], eax<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">2</span>、列出每一行的反汇编代码：<br><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span>******* p7;<br><span class="hljs-keyword">int</span>****** p6;<br><span class="hljs-keyword">int</span>***** p5;<br><span class="hljs-keyword">int</span>**** p4;<br><span class="hljs-keyword">int</span>*** p3;<br><span class="hljs-keyword">int</span>** p2;<br><span class="hljs-keyword">int</span>* p1;<br><br>p1 = &amp;p;<br>p2 = &amp;p1;<br>p3 = &amp;p2;<br>p4 = &amp;p3;<br>p5 = &amp;p4;<br>p6 = &amp;p5;<br>p7 = &amp;p6;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;2<br>mov dword ptr [ebp-4], A;int p = 10;<br>lea eax, dword ptr [ebp-4];&amp;p<br>mov dword ptr [epb-8], eax;p1 = &amp;p<br>lea eax, dword ptr [ebp-8];&amp;p1<br>mov dword ptr [ebp-C], eax;p2 = &amp;p1<br>lea eax, dword ptr [ebp-C];&amp;p2<br>mov dword ptr [ebp-10], eax;p3 = &amp;p2<br>;...<br><br></code></pre></div></td></tr></table></figure><p>攻防世界csaw2013reversing2的复现</p><p>昨天看了wp，今天独立复现一下</p><p>题目描述：听说运行就能拿到Flag，不过菜鸡运行的结果不知道为什么是乱码</p><p>运行程序：</p><p><img src="https://tva2.sinaimg.cn/large/007s2Gz9ly1ghoca8ihiaj30xh0hoaai.jpg" alt="1"></p><p>发送到IDA，F5看一下伪代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl __noreturn <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// ecx</span><br>  CHAR *lpMem; <span class="hljs-comment">// [esp+8h] [ebp-Ch]</span><br>  HANDLE hHeap; <span class="hljs-comment">// [esp+10h] [ebp-4h]</span><br><br>  hHeap = HeapCreate(<span class="hljs-number">0x40000</span>u, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  lpMem = (CHAR *)HeapAlloc(hHeap, <span class="hljs-number">8u</span>, MaxCount + <span class="hljs-number">1</span>);<br>  memcpy_s(lpMem, MaxCount, &amp;unk_409B10, MaxCount);<br>  <span class="hljs-keyword">if</span> ( sub_40102A() || IsDebuggerPresent() )<br>  &#123;<br>    __debugbreak();<br>    sub_401000(v3 + <span class="hljs-number">4</span>, lpMem);<br>    ExitProcess(<span class="hljs-number">0xFFFFFFFF</span>);<br>  &#125;<br>  MessageBoxA(<span class="hljs-number">0</span>, lpMem + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Flag&quot;</span>, <span class="hljs-number">2u</span>);<br>  HeapFree(hHeap, <span class="hljs-number">0</span>, lpMem);<br>  HeapDestroy(hHeap);<br>  ExitProcess(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从if语句看，<code>if ( sub_40102A() || IsDebuggerPresent() )</code>，括号内有一个值为1，就执行if语句中的内容，而<code>sub_40102A()</code>函数的返回值恒为0，所以它对if语句是否执行不产生影响</p><p><strong>一些知识储备：</strong></p><p>1.<code>IsDebuggerPresent() </code>函数读取当前进程的PEB里<code>BeingDebugged</code>的值（值为1，正在被调试）用于判断程序是否处于调试状态</p><p>2.<code>__debugbreak()</code>：中断程序</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">main() <br>&#123;<br>   __debugbreak();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>is similar to:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">main() <br>&#123;<br>   __asm <br>   &#123;<br>      <span class="hljs-keyword">int</span> <span class="hljs-number">3</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>流程分析：</strong></p><p>我们可以看到，如果直接运行程序，即跳过if语句，MessageBox的flag是乱码，那么，想要得到flag，应该是要让if语句中的解密函数执行：</p><ul><li><p>让if语句执行：修改<code>sub_40102A()</code>附近的反汇编，直接jmp；</p></li><li><p>将<code>__debugbreak</code>nop掉；</p></li><li><p>执行<code>sub_401000(v3 + 4, lpMem);</code>后，直接跳到<code>MessageBox</code>，打印解密后的flag。</p></li></ul><p>具体操作就不放上来了，用IDA打补丁也比较方便。</p><p><strong>本题学到的一些知识：</strong></p><p>PEB结构</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PEB</span> </span><br><span class="hljs-class">&#123;</span><br>  BYTE                          Reserved1[<span class="hljs-number">2</span>];<br>  BYTE                          BeingDebugged;<br>  BYTE                          Reserved2[<span class="hljs-number">1</span>];<br>  PVOID                         Reserved3[<span class="hljs-number">2</span>];<br>  PPEB_LDR_DATA                 Ldr;<br>  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;<br>  PVOID                         Reserved4[<span class="hljs-number">3</span>];<br>  PVOID                         AtlThunkSListPtr;<br>  PVOID                         Reserved5;<br>  ULONG                         Reserved6;<br>  PVOID                         Reserved7;<br>  ULONG                         Reserved8;<br>  ULONG                         AtlThunkSListPtr32;<br>  PVOID                         Reserved9[<span class="hljs-number">45</span>];<br>  BYTE                          Reserved10[<span class="hljs-number">96</span>];<br>  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;<br>  BYTE                          Reserved11[<span class="hljs-number">128</span>];<br>  PVOID                         Reserved12[<span class="hljs-number">1</span>];<br>  ULONG                         SessionId;<br>&#125; PEB, *PPEB;<br></code></pre></div></td></tr></table></figure><p>我们暂时只需要重点关注第二个<code>BeingDebugged</code></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
