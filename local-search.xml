<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何理解内存</title>
    <link href="/2022/09/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98/"/>
    <url>/2022/09/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解内存"><a href="#如何理解内存" class="headerlink" title="如何理解内存"></a>如何理解内存</h1><p>首先我们要知道,计算机的工作就是计算. 最重要的组件是cpu——计算机的运算单元,另外,需要计算的数据从哪里来?<br>那就是从内存(memory)中来. 当一个程序运行时, 以这样的一个简单程序为例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> c = a + b;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>cpu运行到主函数中的初始化语句<code>int a = 1, b = 2</code>时, 首先在内存中的两块各32bits(我们知道一般int类型的变量大小为32bits)的空间上存放1和2,<br>编译器自己知道这两块空间分别叫做a和b, 大小是32位</li><li>然后运行到<code>int c = a + b</code>时, 也在内存上开辟一块临时的空间, 标记为<code>c</code>, 大小为32bits,</li><li>然后向内存询问地址为a和b的内存空间上的数据是什么? 需要它们进行计算.  </li></ul><p><strong>cpu首先将a和b的地址通过地址总线传递给内存, 内存在地址总线上读到a的地址后, 将这块地址上存放的数据(1)放到数据总线上, cpu去读数据总线上的数据, 那么就得到了,a的数据, b的数据获取同理.</strong>  </p><h2 id="再看一下我们的汇编代码加深理解"><a href="#再看一下我们的汇编代码加深理解" class="headerlink" title="再看一下我们的汇编代码加深理解  "></a>再看一下我们的汇编代码加深理解  </h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000001149 &lt;main&gt;:<br>    1149:55                   push   rbp<br>    114a:48 89 e5             mov    rbp,rsp<br>    114d:c7 45 f4 01 00 00 00 mov    DWORD PTR [rbp-0xc],0x1  &quot;int a = 1; 把1放到a的内存空间中<br>    1154:c7 45 f8 02 00 00 00 mov    DWORD PTR [rbp-0x8],0x2  &quot;int b = 1; 把2放到b的内存中间中<br>    115b:8b 55 f4             mov    edx,DWORD PTR [rbp-0xc]  &quot;把a的值从内存中读到cpu的edx寄存器中, 准备计算<br>    115e:8b 45 f8             mov    eax,DWORD PTR [rbp-0x8]  &quot;把b的值从内存中读到cpu的eax寄存器中, 准备计算<br>    1161:01 d0                add    eax,edx                  &quot;a + b;         计算a + b, 将结果存放到寄存器eax中<br>    1163:89 45 fc             mov    DWORD PTR [rbp-0x4],eax  &quot;int c = a + b; 将eax中的值存放到c的内存空间中<br>    1166:b8 00 00 00 00       mov    eax,0x0<br>    116b:5d                   pop    rbp<br>    116c:c3                   ret<br></code></pre></div></td></tr></table></figure><p>来解释一下<code>mov DWORD PTR [rbp-0xc],0x1</code>:  </p><ul><li>[rbp-0xc]是一个数值, 表示的是内存中的某一块内存的起始地址(比如说是0x7fffffffdc94)  </li><li>dword是double word的意思, 双字, intel格式的汇编语言是将一个word表示2个bytes, double word就是4个bytes,<br>那么就是32bits(这里知道了大小)</li><li>ptr是pointer, 指针的意思.  </li></ul><p><strong>总而言之, 将1存放到以[rpc-0xc]这块内存地址开头的, 总长度为32bits的内存空间中</strong><br>实际上a在内存中是从0x7fffffffdc94～0x7fffffffdc98 (<em>左闭右开的区间</em>) 这一块连续的32bits大小的空间, 这里是4个间隔, 每一个间隔表示一个字节byte)  </p><blockquote><p>你问到为什么要将8个256-bit的memory连起来?  </p></blockquote><p>这样传一个地址, 那么就能一次性读8bit也就是1byte的数据, 至于为什么不只读1bit或者大一些32bits的数据, 这是当时的历史条件决定的.<br>当时也有6bits这样的大小, 但是因为ascii码用8bits来表示正好, 那么8bits就流行开来, 不管是内存还是磁盘, 都以8bits作为最小的寻址单位<br><a href="https://www.zhihu.com/question/367812743">这里</a>有一些介绍</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造函数和析构函数</title>
    <link href="/2021/10/06/constructor%20and%20destructor/"/>
    <url>/2021/10/06/constructor%20and%20destructor/</url>
    
    <content type="html"><![CDATA[<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>cpp的构造函数有很多写法，比如无参和有参的写法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>嫌麻烦的话，还可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>) : <span class="hljs-built_in">a</span>(x) &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样的话，如果初始化A对象无参数传入</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">A a1;<br></code></pre></div></td></tr></table></figure><p>那么a1.a的值默认为1；</p><p>如果是有参数传入</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">999</span>)</span></span><br></code></pre></div></td></tr></table></figure><p>那么此时a1.a的值为999。</p><h2 id="如何写子类的构造函数"><a href="#如何写子类的构造函数" class="headerlink" title="如何写子类的构造函数"></a>如何写子类的构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>) : <span class="hljs-built_in">A</span>(x), <span class="hljs-built_in">b</span>(y) &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>派生类不会继承基类的</p><ul><li>构造、析构、拷贝构造函数</li><li>重载运算符</li><li>友元函数</li></ul><h1 id="destructor"><a href="#destructor" class="headerlink" title="destructor"></a>destructor</h1><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> _a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a) &#123;&#125;<br>    ~<span class="hljs-built_in">Base</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-comment">// 最好前面加上virtual</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> _b = <span class="hljs-number">0</span>) : <span class="hljs-built_in">b</span>(_b) &#123;&#125;<br>    ~<span class="hljs-built_in">Derived</span>() &#123;std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>需要注意的是，如果用指向基类的指针操作派生类 Derived ，当其生命周期结束后，如果基类析构 不是 virtual function ，只有基类的析构函数被调用，可能会造成派生类的资源没有被释放</strong></p><blockquote><p><strong>为什么基类的析构函数是虚函数？</strong></p></blockquote><blockquote><p> <strong>在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生</strong></p></blockquote></li><li><p><strong>所以务必将 destructor 定义为 virtual function ，尤其是当成员变量有指针时</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;<span class="hljs-keyword">do</span> something&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>当父类的 destructor 为 virtual function 时，派生类的 destructor 默认为 vritual function ，不过最好还是在派生类的 destructor 前加上 virtual</p></li><li><p><strong>有没有必要</strong>将 destructor 声明为纯虚函数？（当有纯虚函数时，该类为抽象基类，不能实例化对象）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~Base = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><p>答案是<strong>能够，但要看情况</strong>。</p><p>那么这样实现的目的是什么呢？当然是<strong>避免实例化</strong>，比如Animal是不应该被实例化的，只有Dog或者Cat被实例化才有具体意义，为了避免Animal实例化，但又因为Animal没有其他的纯虚函数，所以可以将Animal的析构声明为pure virtual function</p><p>但由于<strong>派生类不可能来实现基类的析构函数</strong>，所以<strong>基类析构函数尽管能够标为纯虚，可是仍必须实现析构函数，否则派生类无法继承。也无法编译通过</strong>。</p><p>因为子类调用自己的虚析构函数前，要调用父类的析构函数，而当父类的析构为纯虚函数，如果没有在类外定义函数体，编译会失败，提示<em>没有父类的析构函数</em></p><p>可以为纯虚函数定义一个空的函数体，链接器就能找到基类的虚构函数了</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> _a = <span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br>Base::~<span class="hljs-built_in">Base</span>() &#123;&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编中的指针实现</title>
    <link href="/2021/08/21/reverse-pointer/"/>
    <url>/2021/08/21/reverse-pointer/</url>
    
    <content type="html"><![CDATA[<p>1.汇编中指针及多级指针的实现</p><p>2.一些简单逆向题目的复现</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span>、列出每一行的反汇编代码：<br><br><span class="hljs-keyword">char</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">short</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">int</span> c = <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">char</span>* pa = &amp;a;<br><span class="hljs-keyword">short</span>* pb = &amp;b;<br><span class="hljs-keyword">int</span>* pc = &amp;c;<br><br><span class="hljs-keyword">char</span>** ppa = &amp;pa;<br><span class="hljs-keyword">short</span>** ppb = &amp;pb;<br><span class="hljs-keyword">int</span>** ppc = &amp;pc;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;1<br><br>mov byte ptr [ebp-4], A<br>mov word ptr[ebp-8], 14<br>mov dword[ebp-c] 1E<br><br>lea eax, dword ptr [ebp-4]<br>mov dword ptr [ebp-10], eax<br>lea eax dword ptr [ebp-8]<br>mov dword ptr [ebp-14], eax<br>lea eax, dowrd ptr [ebp-c]<br>mov dword ptr [ebp-18] eax<br><br>lea eax, dword ptr [ebp-10]<br>mov dowrd ptr [ebp-1C], eax<br>lea eax, dword ptr [ebp-14]<br>mov dword ptr [ebp-20], eax<br>lea eax, dword ptr [ebp-18]<br>mov dword ptr [ebp-24], eax<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-number">2</span>、列出每一行的反汇编代码：<br><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span>******* p7;<br><span class="hljs-keyword">int</span>****** p6;<br><span class="hljs-keyword">int</span>***** p5;<br><span class="hljs-keyword">int</span>**** p4;<br><span class="hljs-keyword">int</span>*** p3;<br><span class="hljs-keyword">int</span>** p2;<br><span class="hljs-keyword">int</span>* p1;<br><br>p1 = &amp;p;<br>p2 = &amp;p1;<br>p3 = &amp;p2;<br>p4 = &amp;p3;<br>p5 = &amp;p4;<br>p6 = &amp;p5;<br>p7 = &amp;p6;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">;2<br>mov dword ptr [ebp-4], A;int p = 10;<br>lea eax, dword ptr [ebp-4];&amp;p<br>mov dword ptr [epb-8], eax;p1 = &amp;p<br>lea eax, dword ptr [ebp-8];&amp;p1<br>mov dword ptr [ebp-C], eax;p2 = &amp;p1<br>lea eax, dword ptr [ebp-C];&amp;p2<br>mov dword ptr [ebp-10], eax;p3 = &amp;p2<br>;...<br><br></code></pre></div></td></tr></table></figure><p>攻防世界csaw2013reversing2的复现</p><p>昨天看了wp，今天独立复现一下</p><p>题目描述：听说运行就能拿到Flag，不过菜鸡运行的结果不知道为什么是乱码</p><p>运行程序：</p><p><img src="https://tva2.sinaimg.cn/large/007s2Gz9ly1ghoca8ihiaj30xh0hoaai.jpg" alt="1"></p><p>发送到IDA，F5看一下伪代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> __cdecl __noreturn <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> v3; <span class="hljs-comment">// ecx</span><br>  CHAR *lpMem; <span class="hljs-comment">// [esp+8h] [ebp-Ch]</span><br>  HANDLE hHeap; <span class="hljs-comment">// [esp+10h] [ebp-4h]</span><br><br>  hHeap = HeapCreate(<span class="hljs-number">0x40000</span>u, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  lpMem = (CHAR *)HeapAlloc(hHeap, <span class="hljs-number">8u</span>, MaxCount + <span class="hljs-number">1</span>);<br>  memcpy_s(lpMem, MaxCount, &amp;unk_409B10, MaxCount);<br>  <span class="hljs-keyword">if</span> ( sub_40102A() || IsDebuggerPresent() )<br>  &#123;<br>    __debugbreak();<br>    sub_401000(v3 + <span class="hljs-number">4</span>, lpMem);<br>    ExitProcess(<span class="hljs-number">0xFFFFFFFF</span>);<br>  &#125;<br>  MessageBoxA(<span class="hljs-number">0</span>, lpMem + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Flag&quot;</span>, <span class="hljs-number">2u</span>);<br>  HeapFree(hHeap, <span class="hljs-number">0</span>, lpMem);<br>  HeapDestroy(hHeap);<br>  ExitProcess(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>从if语句看，<code>if ( sub_40102A() || IsDebuggerPresent() )</code>，括号内有一个值为1，就执行if语句中的内容，而<code>sub_40102A()</code>函数的返回值恒为0，所以它对if语句是否执行不产生影响</p><p><strong>一些知识储备：</strong></p><p>1.<code>IsDebuggerPresent() </code>函数读取当前进程的PEB里<code>BeingDebugged</code>的值（值为1，正在被调试）用于判断程序是否处于调试状态</p><p>2.<code>__debugbreak()</code>：中断程序</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">main() <br>&#123;<br>   __debugbreak();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>is similar to:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">main() <br>&#123;<br>   __asm <br>   &#123;<br>      <span class="hljs-keyword">int</span> <span class="hljs-number">3</span><br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>流程分析：</strong></p><p>我们可以看到，如果直接运行程序，即跳过if语句，MessageBox的flag是乱码，那么，想要得到flag，应该是要让if语句中的解密函数执行：</p><ul><li><p>让if语句执行：修改<code>sub_40102A()</code>附近的反汇编，直接jmp；</p></li><li><p>将<code>__debugbreak</code>nop掉；</p></li><li><p>执行<code>sub_401000(v3 + 4, lpMem);</code>后，直接跳到<code>MessageBox</code>，打印解密后的flag。</p></li></ul><p>具体操作就不放上来了，用IDA打补丁也比较方便。</p><p><strong>本题学到的一些知识：</strong></p><p>PEB结构</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">PEB</span> </span><br><span class="hljs-class">&#123;</span><br>  BYTE                          Reserved1[<span class="hljs-number">2</span>];<br>  BYTE                          BeingDebugged;<br>  BYTE                          Reserved2[<span class="hljs-number">1</span>];<br>  PVOID                         Reserved3[<span class="hljs-number">2</span>];<br>  PPEB_LDR_DATA                 Ldr;<br>  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;<br>  PVOID                         Reserved4[<span class="hljs-number">3</span>];<br>  PVOID                         AtlThunkSListPtr;<br>  PVOID                         Reserved5;<br>  ULONG                         Reserved6;<br>  PVOID                         Reserved7;<br>  ULONG                         Reserved8;<br>  ULONG                         AtlThunkSListPtr32;<br>  PVOID                         Reserved9[<span class="hljs-number">45</span>];<br>  BYTE                          Reserved10[<span class="hljs-number">96</span>];<br>  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;<br>  BYTE                          Reserved11[<span class="hljs-number">128</span>];<br>  PVOID                         Reserved12[<span class="hljs-number">1</span>];<br>  ULONG                         SessionId;<br>&#125; PEB, *PPEB;<br></code></pre></div></td></tr></table></figure><p>我们暂时只需要重点关注第二个<code>BeingDebugged</code></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
